%unicode-consumer-max    { #10 }
@unicode-consumer-buf &buf $64 ( 16 * 4 ) ( maybe change to 16 * 3 ?? )
                      &cnt 00 &wr 00
@unicode-consumer-acceptance0 ( -- )
( this is just a passthrought implementation to enable faster development
  of the entire rendering pipeline )

  ,unicode-consumer-buf/cnt LDR DUP unicode-consumer-max LTH ,&cont0 JCN
    POP
    ( signal an error - if you can! )
  RET
  &cont0
    ,unicode-consumer-buf/wr LDR #00 OVR ;unicode-consumer-buf/buf ADD2
  ( stack: cnt wr wrptr* )
    #00 ;utf8result/high LDA OVR2 STA2
    #0002 ADD2
    ;utf8result/mid LDA2 SWP2 STA2
  ( stack: cnt wr )
    #04 ADD ,unicode-consumer-buf/wr STR
    INC ,unicode-consumer-buf/cnt STR

  ;unicode-consumer-release JMP2 ( instead of calling, just jump )
RET

@unicode-consumer-release ( -- )
  ( by the time we get called, there is AT LEAST one codepoint )
       ( ! not if this gets called as a flush. But we're not there yet... )
( this is just a passthrought implementation to enable faster development
  of the entire rendering pipeline )

  ,unicode-consumer-buf/cnt LDR ;unicode-layouter CALL
  #0000 ,unicode-consumer-buf/cnt STR2 ( speed hack? )

  ( The catch is that consumer is basically, in stream mode, going to
    accumulate codepoints until it figures out it received a codepoint
    that is part of another render group, or the render group gets closed
    in some other way. Thus, the buffer is always having valid data,
    starting from 0.
    ... This might get require copying the last codepoint from wherever it
    is in the buffer to the beginning. Alternatively, the codepoint could
    be examined before being put into the buffer. )

  ( Theoretically, there is an option when encountering defective marks,
    that you have to use some "surrogate space" as the base character. In
    the unlikely event the font glyph for it is different that general
    whitespace, I would need to move the entire buffer to accomodate.
    Then again, if processing of codepoints is done before copying them
    into the buffer, the consumer will realize he has a defective mark
    sequence on it's hands and will then be able to monkeypatch this
    replacement space base into the buffer before the mark. )
RET

@unicode-consumer ( -- )

( You will notice this one performs the font dereferencing (glyph lookup).
  Technically, this is total infringement into either the layouter or the
  renderer, but for the time being I'm going to keep it like this. This
  will enable progress at this time of development and as for the rest,
  we'll handle it later. )

  ( overflow protection )
  ( INC is to ensure there are always at least two open slots, this will be
    needed later for proper handling of degenerated combining mark seqs. )
  ;unicode-stream/tot LDA INC unicode-stream-size LTH ,&process JCN
    LIT LBCode-x ( if the render unit ends with an x, the layouter will
                   print everything, including all leading whitespace )
    ;unicode-stream/tot LDA #01 SUB
    ;unicode-layouter CALL
      ( ensure everything is behaving as expected )
      #00 EQU ,&layouter-is-sane JCN
        ( but if the layouter is insane, )
        ( signal an error, and then... ) RET
    &layouter-is-sane
    #01 ;unicode-stream/tot STA
  &process

  ;utf8result/high STH2k LDA STH2r INC2 LDA2
  ;code-bits CALL                              ( this is the dereference )
( stack: codecharptr* )

  ;unicode-stream/tot LDA
  ;unicode-stream/off LDA ADD unicode-stream-mask AND
  ToPosShort STH2

( stack: off* // codecharptr* )
  DUP2 INC LDA
( stack: off* // codecharptr* lbclass )
  ;unicode-lbalgo-data/right-lbclass LDAk STH STA
  STHr ;unicode-lbalgo-data/left-lbclass STA
( stack: off* // codecharptr* )
  ;unicode-lbalgo-data/state LDA ToPosShort
  ;unicode-lbalgo-statecalls ADD2 LDA2 CALL ( note, these may inject U+00A0 )
( stack: off* // codecharptr* lb-code )

  DUP LIT LBCode-x EQU ,&cont1 JCN
    ;unicode-stream/tot LDA
    ;unicode-layouter CALL
    ;unicode-stream/tot STA
    #00 ( dummy value to sync up with the below POP )
  &cont1
  POP
( stack: off* // codecharptr* )

  LDAk
  STH2kr ;unicode-stream/class  ADD2 STA
  #0003 ADD2
  LDAk STH2kr ;unicode-stream/gmdoff ADD2 STA
  INC2

( stack: off* // codecharptr* )
  LDA2k          STH2kr #20 SFT2           ;unicode-stream/bmpoff ADD2 STA2
  INC2 INC2 LDA2 STH2kr #20 SFT2 INC2 INC2 ;unicode-stream/bmpoff ADD2 STA2

( stack: off* // )
  POP2r
  ;unicode-stream/tot LDAk INC ROT ROT STA
RET

@unicode-consumer-flush ( -- ) ( call it at eot )
 ( !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! )
 ( !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! )
 ( !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! )
 ( !!!!!!!!!!!!!!!!!!!!!!! BROKEN !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! )
 ( !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! )
 ( !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! )
 ( !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! )
  #00
  ;unicode-stream/tot LDAk
  STH STA STHkr
( stack: len // len )
  DUP #00 EQU ,&no-display JCN
  ( do-display )
    LIT LBCode-E SWP ;unicode-layouter CALL
    ;unicode-stream/off LDAk STHr ADD unicode-stream-mask AND ROT ROT STA
    RET
  &no-display
    POP POPr
RET
